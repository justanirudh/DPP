/**
 * This class is intended to serve as an example illustrating
 * how a variety of C++ features can be used to implement threadsafe
 * data structures.
 *
 * This is NOT an example of good design for a queue.
 */


//Ensures that this class is only imported once in any file.
#ifndef THREADSAFE_QUEUE_H_
#define THREADSAFE_QUEUE_H_

#include <exception>  //for std::exception
#include <memory>     //for std::shared_ptr
#include <deque>      //for std::queue
#include <mutex>      //for std::mutex and std::lock_guard
#include <iostream>   //for std::ostream

namespace cop5618 {


/**
 * Custom exception to throw when an attempt is made to remove an object
 * from and empty queue.  It inherits from std::exception and overrides
 * the what method to return an appropriate message.
 */
struct empty_queue: public std::exception{


	virtual const char* what() const throw(){
		return "attempt to remove from empty queue";
	}
};


/**
 * This holds an internal queue from the standard template library.
 * Our class is a template (as is the std::queue) so that the queue can
 * hold items of an arbitrary type (subject to some restrictions).
 */
template<typename T>
class threadsafe_queue {


private:

	/**
	 * The non-threadsafe backing data structure from the standard template library.
	 * see http://www.cplusplus.com/reference/deque/deque/
	 *
	 * Guarded by mutex m.
	 */
	std::deque<T> backing_queue;


	/**
	 * We will use this mutex to guard all accesses to data.
	 *
	 * The mutex, which is marked mutable so that methods that do not modify the
	 * object except in acquiring and releasing the lock (for example, size and empty)
	 * can be marked as const.
	 */
	mutable std::mutex m;  //a mutex.


public:

	/**
	 * Introduce type alias for convenience.
	 */
	using size_type = typename std::deque<T>::size_type;

	/**
	 * In C++11, certain so-called special member functions may be,
	 * depending on what has been declared, may be automatically
	 * generated by the compiler.
	 *
	 * For example, the compiler will automatically generate a parameterless
	 * constructor, called the default constructor, as long as no other
	 * constructors have been declared. If you need to declare it because you
	 * have other constructors, but would be happy to have the compiler's
	 * implementation (which uses default constructors to initialize
	 * the data members) for the class, you can do this with "=default".
	 *
	 * Note that mutexes are not movable or copyable, so neither are classes
	 * that use them.
	 *
	 */

	threadsafe_queue<T>()=default;

	/**
	 * This is a programmer provided constructor that
	 * will take an std::queue and moves it into a new
	 * threadsafe queue.  The explicit keyword is needed for single argument
	 * constructors to prevent C++ from thinking that the constructor is a type
	 * conversion operation.  We will provide the implementation below.
	 */
	explicit threadsafe_queue<T>(std::deque<T>&& data);

	/**
	 * This is the declaration of the copy constructor.
	 * A copy constructor doesn't make sense for our class, so
	 * use "=delete" to indicate that the copy constructor should not
	 * be generated or called.  (Prior to C++11, the standard practice
	 * was to declare an undesired constructor as private and omit the
	 * definition. In C++11, the best practice is to make the constructor
	 * public with "=delete")
	 */
	explicit threadsafe_queue<T>(const threadsafe_queue<T>& other)=delete;

	/**
	 * We don't want an assignment constructor
	 */
	threadsafe_queue<T>& operator=(const threadsafe_queue<T>& other)=delete;

	/**
	 * We don't want a move constructor
	 */
	threadsafe_queue<T>(threadsafe_queue<T>&& other)=delete;

	/**
	 * We don't want a move assignment constructor
	 */
	threadsafe_queue<T>& operator=(threadsafe_queue<T>&& other)=delete;

	/**
	 * The compiler generated destructor, which just calls the destructor
	 * on all the members, is fine.
	 */
	~threadsafe_queue<T>()=default;





	 /**
	  * The next two methods size, and empty simply return the
	  * results of calling the function of the same name from the
	  * backing queue.
	  *
	  * These methods are declared to be const like the methods
	  * on the backing queue.  This is the case even though
	  * the mutex m is modified.  This is allowed since we have
	  * declared m to be mutable.
	  */

	/**
	 * returns whether or not the queue is empty.
	 *
	 * This is a declaration.  The definition is given below the class.
	 */
	bool empty() const;

	/**
	 * returns the number of elements in the queue.
	 *
	 */
	size_type size() const;




	/**
	 * Adds a new element at the end of the queue, after its current last element.
	 * The content of val is copied to the new element.
	 *
	 * This effectively increases the queue size by one.
	 */
	void push(const T& val);

	/**
	 * Adds a new element at the end of the queue, after its current last element.
	 * The content of val is moved to the new element.
	 *
	 * This effectively increases the queue size by one.
	 */
	void push(T&& val);

	/**
	 * Returns a shared_ptr wrapping the element in front of the queue.
	 * Then removes the item from the queue.  (This is different from the
	 * semantics of front in the backing queue, which returns the shared
	 * pointer but does not pop the element off the backing queue.)
	 */
	std::shared_ptr<T> front();

	/**
	 * Copies the value of the element at the front of the queue to the
	 * object referred to by val.  The element is then removed from the
	 * queue.    (This is different from the semantics of front in the
	 * backing queue, which returns the shared pointer but does not pop
	 * the element off the backing queue.)
	 */
	void front(T& val);

	/**
	 * It is common practice to overload the << operator to print the contents of
	 * the queue. This is not a method in the class, but it is declared as a friend
	 * function so that it can access the private data of this class.
	 *
	 * Note that the template parameter (U) must be different from the one used
	 * for the class itself (T).
	 */
	template <typename U>
	friend std::ostream& operator<< (std::ostream& os, const threadsafe_queue<U>& obj);

	/**
	 * This should only be used for testing!
	 */
	std::deque<T>& get_backing_queue();
}; //class threadsafe_queue


/** Below are the definitions of the methods.
 * Since this class is a template,  the implementation needs to be
 * in the same file.  If it were a normal non-template class, we would probably
 * put the implementations in a separate .cpp file.
 */
template<typename T>
threadsafe_queue<T>::threadsafe_queue(std::deque<T>&& data){
	std::lock_guard<std::mutex> lock(m);
	backing_queue = data;
}

/**
 * Definition of empty.
 *
 * First, we declare that this is a template function.
 * Then, we indicate (before the name of the function) that this belongs to the
 * threadsafe_queue<T> class.
 *
 * Access to backing_queue is guarded by mutex m.  We use the
 * lock_guard template to lock it.  This locks mutex m, and releases
 * it when the variable lock goes out of scope.  This RAII-type handling
 * of the mutex ensures that it will be released when control leaves the
 * funcion, whether normally or if an exception is thrown.
 */
template<typename T>
bool threadsafe_queue<T>::empty() const{
	std::lock_guard<std::mutex> lock(m);
	return backing_queue.empty();
}

/**
 * Definition of size.
 *
 * We need the typename keyword here because threadsafe_queue<T>::size_type
 * is a dependent scope.  (In my experience, you don't need to worry too much
 * about dependent scopes.  The compiler will tell you that you need to add
 * typename)
 */
template<typename T>
typename threadsafe_queue<T>::size_type  threadsafe_queue<T>::size() const{
	std::lock_guard<std::mutex> lock(m);
	return backing_queue.size();
}


/**
 * As the previous methods, this uses the mutex m to guard access to the
 * shared backing_queue structure, backing_queue.
 */
template<typename T>
void threadsafe_queue<T>::push(const T& val){
	std::lock_guard<std::mutex> lock(m);
	backing_queue.push_back(val);
}

template<typename T>
void threadsafe_queue<T>::push(T&& val){
	std::lock_guard<std::mutex> lock(m);
	backing_queue.push_back(val);
}

template<typename T>
std::shared_ptr<T> threadsafe_queue<T>::front(){
	std::lock_guard<std::mutex> lock(m);
	if(backing_queue.empty()) throw empty_queue();
	std::shared_ptr<T> const res(std::make_shared<T>(backing_queue.front()));
	backing_queue.pop_front();
	return res;
}

template<typename T>
void threadsafe_queue<T>::front(T& val){
	std::lock_guard<std::mutex> lock(m);
	if (backing_queue.empty()) throw empty_queue();
	val = backing_queue.front();
	backing_queue.pop_front();
}

template <typename T>
std::ostream& operator<< (std::ostream& os, const threadsafe_queue<T>& obj){
	//acquire the lock
	std::lock_guard<std::mutex> lock(obj.m);
	//iterate over the contents of the backing deque
	for (auto iter = obj.backing_queue.begin(); iter != obj.backing_queue.end(); ++iter){
		if (iter != obj.backing_queue.begin()){os << ",";}//skip preceding comma if first one
		os << *iter;
	}
	return os;
}

template<typename T>
std::deque<T>& threadsafe_queue<T>::get_backing_queue(){
	return backing_queue;
}


} /* namespace cop5618 */

#endif /* THREADSAFE_QUEUE_H_ */
